"""
Ingest module for the Knowledge Graph component.
"""

import os
import pandas as pd
import numpy as np
import yaml
import re
from typing import Dict, Any, Optional
from neo4j_runway import PyIngest
from neo4j_runway.code_generation import PyIngestConfigGenerator


def ingest_to_neo4j(df: pd.DataFrame, model: Any, config: Dict[str, Any]) -> bool:
    """
    Ingest data to Neo4j using the generated model.

    Args:
        df: DataFrame to ingest
        model: Graph model generated by Neo4j Runway
        config: Knowledge graph configuration

    Returns:
        True if successful, False otherwise
    """
    try:
        # Get Neo4j connection details
        neo4j_uri = config.get("neo4j_uri", "neo4j://192.168.2.2:7687")
        database = config.get("database", "neo4j")
        
        # Create a clean directory for the CSV file
        clean_dir = config.get("output_dir", "./kg_output")
        os.makedirs(clean_dir, exist_ok=True)
        
        # Clean the DataFrame
        df_clean = clean_dataframe(df)
        
        # Save DataFrame to CSV with absolute path
        clean_csv_file = "clean_data.csv"
        clean_csv_path = os.path.abspath(os.path.join(clean_dir, clean_csv_file))
        df_clean.to_csv(clean_csv_path, index=False)
        
        print(f"Data saved to {clean_csv_path}")
        
        # Generate PyIngest configuration
        gen = PyIngestConfigGenerator(
            data_model=model,
            uri=neo4j_uri,
            database=database,
            file_directory=os.path.dirname(clean_csv_path),
            source_name=clean_csv_file
        )
        
        # Generate YAML configuration
        pyingest_yaml = gen.generate_config_string()
        
        # Fix any column references if needed
        for col in df.columns:
            safe_col = col.replace(".", "_").replace(" ", "_").lower()
            if col != safe_col:
                pyingest_yaml = pyingest_yaml.replace(f"row.{col}", f"row.{safe_col}")
        
        # Parse YAML and fix file URLs
        config_dict = yaml.safe_load(pyingest_yaml)
        if "files" in config_dict:
            for file_entry in config_dict["files"]:
                if "url" in file_entry:
                    # Use the absolute path directly
                    file_entry["url"] = clean_csv_path
        
        # Convert back to YAML string
        pyingest_yaml = yaml.dump(config_dict)
        
        # Ensure all required columns exist in the DataFrame
        df_clean = ensure_dynamic_required_columns(df_clean, pyingest_yaml)
        df_clean = clean_dataframe(df_clean)
        
        # Save the final cleaned CSV
        df_clean.to_csv(clean_csv_path, index=False)
        
        # Create a direct connection to Neo4j
        print(f"Ingesting data to Neo4j at {neo4j_uri}...")
        
        # Use direct PyIngest with the YAML configuration
        PyIngest(config=pyingest_yaml, verbose=True)
        
        print(f"Data successfully ingested into Neo4j at {neo4j_uri}")
        return True
        
    except Exception as e:
        print(f"Error ingesting data to Neo4j: {e}")
        import traceback
        traceback.print_exc()
        return False


def clean_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Clean a DataFrame for Neo4j ingestion.
    
    Args:
        df: DataFrame to clean
        
    Returns:
        Cleaned DataFrame
    """
    df_clean = df.copy()
    
    for col in df_clean.columns:
        if pd.api.types.is_numeric_dtype(df_clean[col]):
            df_clean[col] = df_clean[col].apply(lambda x: 0 if pd.isna(x) or (isinstance(x, float) and np.isnan(x)) or x == "" else x)
        elif pd.api.types.is_datetime64_any_dtype(df_clean[col]):
            df_clean[col] = df_clean[col].fillna(pd.Timestamp("1970-01-01"))
        else:
            df_clean[col] = df_clean[col].replace({None: "UNKNOWN", pd.NA: "UNKNOWN"}).fillna("UNKNOWN")
            df_clean[col] = df_clean[col].astype(str).apply(lambda x: "UNKNOWN" if x.lower() in ["nan", "none", "null", ""] else x)
    
    # Final cleaning pass
    df_clean = df_clean.apply(lambda col: col.map(final_clean_value))
    df_clean.replace(r'^\s*$', "UNKNOWN", regex=True, inplace=True)
    df_clean.fillna("UNKNOWN", inplace=True)
    
    return df_clean


def final_clean_value(x: Any) -> str:
    """
    Clean a single value for Neo4j ingestion.
    
    Args:
        x: Value to clean
        
    Returns:
        Cleaned value as string
    """
    if pd.isna(x):
        return "UNKNOWN"
    try:
        s = str(x).strip()
    except Exception:
        return "UNKNOWN"
    return "UNKNOWN" if s.lower() in ["", "nan", "none", "null"] else s


def ensure_dynamic_required_columns(df: pd.DataFrame, yaml_str: str) -> pd.DataFrame:
    """
    Ensure all columns referenced in the YAML exist in the DataFrame.
    
    Args:
        df: DataFrame to check
        yaml_str: YAML string with column references
        
    Returns:
        DataFrame with all required columns
    """
    cols_in_yaml = re.findall(r"row\.([a-zA-Z0-9_.]+)", yaml_str)
    for col in set(cols_in_yaml):
        if col not in df.columns:
            df[col] = f"UNKNOWN_{col.replace('.', '_').upper()}"
    return df